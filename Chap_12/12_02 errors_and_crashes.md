# Errors and Crashes

우리의 Web 어플리케이션이 일단 가동되면 여러 가지 오류가 발생할 수 있습니다. Web 어플리케이션의 일상의 실행에서는 여러 가지 오류가 발생할 수 있습니다. 구체적으로는 다음과 같습니다 :

- 데이터베이스 오류 : 데이터베이스 서버에 대한 액세스 또는 데이터와 관련된 오류입니다. 예를 들어, 다음은 어떤 데이터베이스 오류를 발생시킬 수 있습니다.

- 연결 오류 :이 오류는 데이터베이스 서버의 네트워크 연결이 해제 된 경우 또는 사용자 이름과 비밀번호가 부정했던 경우 또는 데이터베이스가 존재하지 않는 경우에 발생할 수 있습니다.
- 검색 오류 : 사용 된 SQL이 잘못없고, 오류가 발생하는 경우입니다. 이러한 SQL 오류는 만약 프로그램에 엄격한 테스트를 방지 할 수 있습니다.
- 데이터 오류 : 데이터베이스의 약속이 충돌하는 경우. 예를 들어 하나 밖에없는 필드에 여러 기본 키를 가진 데이터가 삽입되면 오류를 발생시킵니다. 그러나 당신의 애플리케이션 프로그램이 운용되기 전에 엄격한 테스트를 수행하여 이러한 문제를 해결 할 수 있습니다.
- 응용 프로그램 실행시 오류 :이 오류의 범위는 매우 넓고, 코드에서 출현하는 거의 모든 오류를 다루고 있습니다. 있을 수 응용 프로그램 오류는 다음과 같은 상황입니다 :

- 파일 시스템 권한 : 응용 프로그램이 존재하지 않는 파일을 가져 오거나 권한이없는 파일을 읽거나 쓸 허용되지 않은 파일에 쓰는 등 이러한 행위는 모든 오류를 발생시킵니다. 만약 응용 프로그램이로드 파일 형식이 잘못 된 경우에도 오류를 발생시킵니다. 예를 들어 설정 파일이 ini 설정 형식이어야하는데, json 형식으로 설정되어 있으면 오류를 발생시킵니다.
- 타사 응용 프로그램 : 만약 우리의 응용 프로그램을 다른 타사 인터페이스 프로그램과 결합하면, 예를 들어 응용 프로그램이 텍스트를 출력하고 자동으로 마이크로 블로그의 인터페이스를 호출하면이 인터페이스는 제대로 실행되지 않으면 하면 우리의 텍스트를 출력하는 기능은 제공 할 수 없습니다.

- HTTP 오류 :이 오류는 사용자의 요청에 의해 발생하는 오류입니다. 가장 전형적인 예로 404 오류입니다. 그 외에도 많은 오류가 발생할 수는있다해도 다른 빈번한 오류는 401 무단 오류 (인증을 통해 액세스 할 수있는 리소스) 403 액세스 거부 오류 (사용자가 리소스에 액세스하는 것을 거부)와 503 오류 (내부 프로그램 오류)입니다.
- 운영 체제 오류 :이 오류는 모든 응용 프로그램의 운영 시스템에 의해 발생하는 것입니다. 주로 운영 체제의 자원이 분배되거나 정지를 유발하거나 운영 체제의 하드 디스크를 가득 쓸 수 없게하는 등 많은 오류를 일으 킵니다.
- 네트워크 오류 : 이것은 두 가지 오류를 나타냅니다. 하나는 사용자가 응용 프로그램에 요청을 할 경우 네트워크가 끊어져 버리는 것으로, 네트워크 연결이 중단되어 버립니다. 이러한 오류는 응용 프로그램의 붕괴야말로 초래하지 않지만 사용자의 액세스 효과에 영향을 미칩니다. 또 하나는 응용 프로그램이 다른 네트워크에 데이터를 읽고 다른 네트워크가 절단하여로드에 실패하는 것입니다. 이들은 응용 프로그램에 유효한 테스트를 실시함으로써 이러한 문제가 발생하는 상황에서 응용 프로그램이 붕괴하는 것을 방지 할 수 있습니다.

## 오류 처리 목표
오류 처리를 구현하기 전에 오류 처리를 목표로 목표가 무엇인가를 명확히해야합니다. 오류 처리 시스템은 다음과 같은 작업하에 수행합니다.

- 액세스하는 사용자에게 에러의 발생을 통지하는 : 발생한 시스템 오류 든 사용자 오류 든 사용자는 Web 응용 프로그램에 문제가 사용자의 이번 요청이 성공적으로 완료되지 않은 것을 알 필요가 있습니다. 예를 들어, 사용자의 오류 요청에, 우리는 일반적인 오류 화면 (404.html)을 표시합니다. 시스템 오류가 발생한 경우 사용자 정의 된 오류 화면을 통해 시스템이 일시적으로 사용할 수없는 등 종류의 오류 화면 (error.html)을 표시합니다.
- 로그 오류 : 시스템 오류가 발생, 즉 일반적으로 함수를 호출 할 때 반환되는 err가 nil이 아닌 상황에서 앞 절에서 소개 한 로그 시스템을 사용하여 로그 파일에 기록 수 있습니다. 예를 들어 중요한 오류 였다고하면 우편을 통해 시스템 관리자에게 알립니다. 404 같은 오류는 보통 이메일을 보내 같은 것은 필요하지 않지만 로그 시스템에 기록해야합니다.
- 현재 요청 작업을 롤백 :있는 사용자의 요청 중에 서버 오류가 발생했습니다. 이미 완료 한 작업을 롤백해야합니다. 여기에서는 예를 하나 들겠습니다 :있는 시스템이 사용자의 보낸 양식을 데이터베이스에 저장하고이 데이터를 타사 서버로 전송하면됩니다. 그러나 타사의 서버가 죽어 오류를 발생시킨하면 사전에 데이터베이스에 저장된 양식 데이터는 삭제되어야하며 (알림은 해제되어야합니다) 사용자의 시스템에 오류 가 발생한 것을 통지하여야합니다.
- 현재 프로그램이 실행하고 서비스 할 수 있는지 확인하기 : 프로그램이 반드시 항상 성공적으로 실행되는 것을 보장 할 수있는 인간은 빈자리를 우리는 알고 있습니다. 만일 언젠가 프로그램이 망가져 버리면 오류를 기록해야합니다. 잠시 후 프로그램을 다시 시작하고 프로그램에 서비스를 제공하는 것을 계속합니다. 이후 시스템 관리자에게 알립니다 로그 등을 통해 문제를 찾습니다.

## 어떻게 오류를 처리하는 방법
오류 처리는 사실 우리도 제 11 장 제 1 절에서 어떻게 오류 처리를 설계하거나 소개했습니다. 여기에 또 하나의 예에서 상세하게 설명합니다. 어떻게 다른 오류를 처리하는 것일까 요 :

- 사용자에게 오류가 발생했음을 알리는 :

사용자가 페이지에 액세스 할 때 두 가지 오류가 있습니다 : 404.html과 error.html입니다. 다음은 각 오류 페이지를 표시하는 소스입니다 :

<html lang = "en">
<head>
<meta http-equiv = "Content-Type"content = "text / html; charset = utf-8">
<title> 페이지를 찾을 수 없습니다 </ title>
<meta name = "viewport"content = "width = device-width, initial-scale = 1.0">

</  head>
< body >
<div class = "container">
<div class = "row">
<div class = "span10">
<div class = "hero-unit">
<h1> 404! </ h1>
<p> {{. ErrorInfo}} </ p>
</ div>
</ div> <! - / span ->
</ div>
</ div>
</ body>
</ html>
또 소스 :

<html lang = "en">
<head>
<meta http-equiv = "Content-Type"content = "text / html; charset = utf-8">
<title> 시스템 오류 페이지 </ title>
<meta name = "viewport"content = "width = device-width, initial-scale = 1.0">

</ head>
<body>
<div class = "container">
<div class = "row">
<div class = "span10">
<div class = "hero-unit">
<h1> 시스템 잠시 사용할 수 없습니다! </ h1>
<p> {{. ErrorInfo}} </ p>
</ div>
</ div> <! - / span ->
</ div>
</ div>
</ body>
</ html>

404 오류 처리 로직, 만약 시스템의 오류 인 경우도 비슷한 작업입니다. 다음을 살펴 보자 :

func (p * MyMux) ServeHTTP (w http.ResponseWriter, r * http.Request) {
if r.URL.Path == "/"{
sayhelloName (w, r)
return
}
NotFound404 (w, r)
return
}

func NotFound404 (w http.ResponseWriter, r * http.Request) {
log.Error ( "페이지를 찾을 수 없습니다") // 오류 기록
t _ = t.ParseFiles ( "tmpl / 404.html", nil) // 템플릿 파일을 분석
ErrorInfo : = "파일을 찾을 수 없습니다"// 현재 사용자 정보를 취득
t.Execute (w, ErrorInfo) // 템플릿 merger 작업을 수행
}

func SystemError (w http.ResponseWriter, r * http.Request) {
log.Critical ( "시스템 오류") // 시스템 오류는 중요하므로 기록뿐만 아니라 이메일을 보냅니다.
t _ = t.ParseFiles ( "tmpl / error.html", nil) // 템플릿 파일을 분석
ErrorInfo : = "시스템은 현재 이용하실 수 없습니다"// 현재 사용자 정보를 취득
t.Execute (w, ErrorInfo) // 템플릿 merger 작업을 수행
}

## 어떻게 예외를 처리하는 방법
많은 다른 언어 중에는 try..catch 키워드가있는 것을 알고있을 것입니다. 예외를 캐치하기 위해서 사용하는 상황입니다 만, 원래 오류의 대부분은 미리 발생을 예측할 수있는 것만 예외 처리를 할 필요가 없습니다. 오류로 처리해야한다 것도 Go 언어가 함수에 오류를 반환하는 설계가되어 있기 때문입니다. 이것은 panic되지 않습니다. 만약 당신이 끊어진 네트워크 연결에 데이터를 쓸 경우 net.Conn 시리즈의 Write 함수가 오류를 반환합니다. 이들은 panic되지 않습니다. 이러한 상태는이 같은 프로그램에서 예측할 수있는 것입니다. 당신이 이러한 작업이 실패 할 수있는 알고있는 것은 설계자가 오류를 반환하여 명확하게이를 표명하고 있기 때문입니다. 이것이 위에서 말한 발생이 예측 가능한 오류입니다.

그러나 또 다른 상황도 있습니다. 있는 작업이 거의 실패하지 않고, 특정 상황에서 오류를 반환 할 수없이 계속 수행 할 수없는 경우 panic입니다. 예를 들어 보자 : 만약 프로그램이 x [j]를 계산 한 결과 j가 범위를 벗어 버렸을 경우,이 부분의 코드는 panic이 발생합니다. 이처럼 예측할 수없는 심각한 오류가 panic이 발생합니다. 기본적으로 이것은 프로세스를 죽이고 있습니다. 이것은 현재 실행되는 코드의 goroutine이 오류를 발생시킨 panic에서 복귀하는 것을 허락합니다. 이것은 Go がわざと 이러한 설계하고 오류와 예외를 구별하기위한 것이다. panic는 사실 예외입니다. 다음 코드에서는 uid 의해 User의 username 정보를 취득하는 것을 기대하고 있습니다 만, uid가 범위를 초과하면 예외를 발생시킵니다. 이때 만약 recover 메커니즘이 없으면 프로세스가 살해함으로써 프로그램이 서비스 불능에 빠지게됩니다. 그러므로 프로그램의 건전성을 유지하기 위해 어떤 장소에서 recover 메커니즘을 만들 필요가 있습니다.

func GetUser (uid int) (username string) {
defer func () {
if x : = recover (); x! = nil {
username = ""
}
} ()

username = User [uid]
return
}

위의 오류와 예외의 구별을 소개했습니다. 우리가 프로그램을 개발할 때 어떻게 설계 할 것인가? 규칙은 매우 간단합니다 : 당신이 정의한 함수가 실패 할 가능성이 있다면, 오류를 반환해야합니다. 다른 package의 함수를 호출 할 때, 만약이 함수의 구현이 매우 좋은 경우 panic 걱정을 할 필요도 없습니다. 정말 예외를 발생시켜야하는 상황이 아닌데 발생시켜 버리고있다해도 내가 이것을 처리하는 까닭은 없을 것입니다. panic과 recover는 자신이 개발 한 package로 구현 된 로직이나 특수한 상황에 대해 설계됩니다.

## 정리
이 절에서는 우리의 Web 응용 프로그램을 배포 한 후 어떻게하여 다양한 오류를 처리하는 방법에 대해 정리했습니다 : 네트워크 오류 데이터베이스 오류, 운영 체제 오류 등 오류가 발생했을 때, 우리의 프로그램은 어떻게 하고 올바르게 처리하는 것입니까 : 사용자 친화적 인 오류 인터페이스를 표시하고 작업을 롤백 로그를 기록하고 관리자에게 통보하는 등의 작업을 수행합니다. 마지막으로 어떻게 오류와 예외를 올바르게 처리하는 방법에 대해 소개했습니다. 일반적인 프로그램에서는 오류와 예외는 자주 혼동됩니다. 그러나 Go는 오류 및 예외는 항상 명확한 구분이 이루어집니다. 따라서 우리가 프로그램을 디자인 할 때 오류와 예외를 처리 할 때 어떤 원칙에 따라야 할 것인가에 대해 소개했습니다.
