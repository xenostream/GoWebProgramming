# Go Command
#### Go 명령어
Go 언어는 명령어로만 모든 작동을 할 수 있는 환경을 제공합니다.    
바로, ```go``` 명령어로 수행합니다. 명령창에서 *go* 명령을 입력하면 다음과 같습니다.   


![](/images/1_3_go.png)    
 <그림 1. 3> go 명령어 화면      
 
 
 #### go build
 컴파일 타입 언어의 컴파일 명령에 속합니다. 연관된 패키지가 있다면 같이 컴파일 합니다.     
 
* 1.2절에서 보았듯이 ```main``` 패키지가 존재하지 않는다면, *go build*명령어를 사용해도      
   실행파일을 생성하지 않습니다. (라이브러리 패키지)    
   ```$GOPATH/pkg``` 디렉토리에 컴파일된 라이브러리 파일을 만들려면```go install```명령을    
   사용하시기 바랍니다. 

* 만약에 ```main```패키지를 가지고 있다면,(응용프로그램 패키지) 현재 디렉토리에 실행파일을    
  생성하게 됩니다. 만약 ```$GOPATH/bin``` 디렉토리에 실행파일을 생성하기 원한다면,     
  ```go install 또는 go build -o ${PATH}/a.exe```와 같이 원하는 파일을 지정하면 됩니다. 

* 만약 현재 디렉토리에 많은 소스파일이 존재한다면, 컴파일을 원하는 파일명을 지정하면 됩니다.    
  예를들어 *a.go*파일만을 컴파일 하려면, ```go build a.go``` 라는 명령을 수행하시기 바랍니다.    

* 컴파일할때 실행파일이름을 지정할 수 있습니다. 예를 들어서, *mathapp*프로그램의 결과 파일을   
  **xeno.exe**로 지정하기 위해서는 다음과 같이 명령합니다. ```go build -o xeno.exe```   
  기본적으로 생성하는 실행파일 이름은 디렉토리 이름으로 생성됩니다. (main패키지가 포함된...)   

* ```go build``` 명령으로 컴파일 할 경우 ```_(언더바) 또는 . (점)```으로 시작하는 파일은   
  컴파일에서 제외합니다. 

* 만약, 운영체제별로 그에 맞는 파일만 컴파일 할 경우에는, ```array_```라는 접두어로 파일명을 지정   
  해서 처리합니다.  ``` array_linux.go | array_darwin.go | array_windows.go | array_freebsd.go```
  현재 운영체제가 만약 리눅스라면 *array_linux.go* 파일만 컴파일 하게 됩니다. 

#### go clean
컴파일러가 컴파일 할 때 생성했던 모든 파일을 제거하는 작업입니다. 컴파일 시에 생성되는 파일은    
다음과 같은 파일이 존재할 수 있습니다. 
```
_obj
_test/
_testmain.go
test.out
build.out
*.[568ao]
DIR(.exe)
DIR.test(.exe)
MAINFILE(.exe)
```
이 명령은 GitHub.Com에 소스를 올리기 직전에 수행하여, 필요한 파일만 업로드할 경우에 주로 사용합니다. 


#### go fmt / gofmt
C/C++/Java와 같은 언어에서의 항상 고민되는 문제는 코딩스타일이 사람마다 다르기 때문에, 다른사람이   
작성한 소스코드를 읽을 경우 힘든 문제가 발생한다는 것입니다. (KR&C / ANSI-C ...)    
하지만, **Go**언어에서는 이러한 문제가 발생하지 않습니다. 한가지 코딩스타일만 존재하고 강제적입니다.   
예를 들어서, 여는 대괄호({)는 반드시 문장의 끝에서만 열어야만 합니다. 이것은 강제적입니다.   
이러한 코딩 규칙을 별도로 배워둘 필요는 없습니다. 바로 ```go fmt```명령이 존재하기 때문입니다.    
**go fmt**명령은 소스코드를 *go*언어의 코딩스타일에 맞도록 자동으로 소스코드를 정렬해 주는 명령입니다.

하지만, 이 명령을 별도로 수행하는 경우는 자주 없습니다.**Go IDE**들에서 이것을 자동으로 처리하기   
때문입니다. 대부분의 경우 소스코드를 컴파일 하거나, 저장할 경우에 자동으로 *go fmt*명령을 수행합니다.  

실제로 ```go fmt```명령은 ```gofmt``` 명령파일의 대체이름일 뿐입니다. 

```gofmt -w <소스파일명>``` 옵션은 정렬한 소스코드를 현재 소스코드에 곧바로 적용할 때 사용합니다.   

#### go get
이 명령은 원격저장소에 저장된 소스코드를 가져오는 명령입니다. BitBucket, Github, Google Code등의   
현재 유용하게 사용하는 원격저장소 서비스에 접속해서 해당하는 패키지의 소스를 가져오게 됩니다.   
이 명령은 실제로는 두가지 작업으로 처리되게 됩니다. 첫 뻔째는 소스코드를 다운로드 합니다.   
그리고 다운로드 받은 소스코드를 ```go install```명령을 호출해서 현재 시스템에 설치하는 작업을    
수행하게 되는 것입니다. 
```go help remote``` 명령을 통해서 현재 지원되는 원격저장소에 관련된 도움말을 볼 수 있습니다. 


#### go install
소스코드를 컴파일 하고, 패키지가 생성하는 중요한 파일을 ```$GOPATH/pkg 또는 $GOPATH/bin``` 디렉토리  
에 복사한 후 설치하는 명령어 입니다. 

#### go test
이 명령은 ```*-test.go``` 형식으로 테스트용 파일로 생성하며 다음과 같은 정보를 표시합니다. 
```
ok   archive/tar     0.011s
FAIL archive/tar     0.02s
ok   compress/gzip   0.033s
...
```
**go help testflag**명령으로 통해서 보다 자세한 사항을 살펴 볼 수 있습니다. 


### go doc
대부분의 개발자들은 별도의 도움말 및 문서화 시스템을 사용하는 것을 원하지 않습니다. 개발환경에서   
자체적으로 제공하기를 바랍니다. (Java의 javadoc) *Go*언어에서는 기본적으로 문서화기능을 제공합니다. 

*Go*언어에서 기본적으로 제공하는 패키지에 대하여 문서를 생성하려면, ```godoc builtin```명령형식으로   
사용하면 됩니다. 예를 들어 net/http패키지에 대한 문서는 ```godoc net/http```명령을 사용합니다.   
또한, fmt.Printf 함수에 대한 문서를 보려면 ```godoc fmt Printf``` 와 같은 명령을 사용합니다.    

```godoc -http=:8080```명령을 사용하면, 웹브라우저를 열고 ```http://127.0.0.1:8080```주소를    
입력해서 웹브라우저에서 내용을 살펴볼 수 있게 됩니다. 


#### Etc
다음과 같은 명령들도 제공합니다. ``` go help <명령어> ``` 형식으로 직접 알아보시기 바랍니다. 
```
go fix          구버전에서 작성한 소스를 현재 버전으로 업그레이드 합니다. (Go버전 입니다.)
go version      현재 설치된 Go언어의 버전정보를 표시합니다.
go env          현재 Go언어에서 사용하는 여러가지 환경변수를 표시합니다.(GOOS, GOROOT, GOPATH...)
go list         현재 시스템에 설치된 패키지를 표시합니다. 
go run          실행파일을 생성하지 않고 곧바로 소스를 컴파일하고 실행합니다. 
```





 
 
