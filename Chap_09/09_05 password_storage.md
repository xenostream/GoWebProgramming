# Password Storage

조금 전부터 많은 페이지에서 사용자의 암호가 노출하는 사건이 발생하고 있습니다. 여기에는 최고 수준의 인터넷 기업이 포함되어 있습니다 - Linkdin 국내에서는 CSDN 사건이 국내 인터넷에서 뛰어 돌아했습니다. 또한 多玩 유희의 800 만 사용자 데이터를 유출했습니다. 또한 런 런왕, 開心網, 천애 구 세기 佳縁, 백합 망 등 커뮤니티도 해커의 다음 목표되었다고 소문이 있습니다. 끊임없는 유사한 사건이 사용자의 인터넷 생활에 큰 영향을주고 있습니다. 사람들은 자위하고 사람들은 종종 다른 웹 사이트에서 동일한 암호를 사용하는 것에 익숙해 져 있기 때문에, 한 곳에서 데이터베이스가 폭로되어 버리면 모든 영향이 있습니다.

Web 어플리케이션 개발자로 암호 저장 방법을 선택할 때 어떤 함정에 빠지기가되는 것입니까? 또한 어떻게하여 이러한 함정을 피해야 할 것인가?

## 보통의 방법
현재 가장 많이 사용되는 암호 저장 방법은 일반 텍스트 암호를 단방향 해시 걸쳐 저장하는 것입니다. 단방향 해시 알고리즘의 특징은 : 해시 된 후에 다이제스트 (digest)에서 원래 데이터를 복원 할 수 없다는 것입니다. 이것이 "단방향"이라는 것의 이유입니다. 자주 사용하는 단방향 해시 알고리즘은 SHA-256, SHA-1, MD5 등이 있습니다.

Go 언어의이 세 가지 암호화 알고리즘의 구현은 다음과 같다 :

// import "crypto / sha256"
h : = sha256.New ()
io.WriteString (h "His money is twice tainted : 'taint yours and'taint mine.")
fmt.Printf ( "% x", h.Sum (nil))

// import "crypto / sha1"
h : = sha1.New ()
io.WriteString (h "His money is twice tainted : 'taint yours and'taint mine.")
fmt.Printf ( "% x", h.Sum (nil))

// import "crypto / md5"
h : = md5.New ()
io.WriteString (h "암호화해야하는 암호")
fmt.Printf ( "% x", h.Sum (nil))

단방향 해시에는 2 개의 특징이 있습니다 :

- 1) 동일한 암호를 단방향 해시에 걸면 언제든지 독특한 확정 된 다이제스트를 얻습니다.
- 2) 빠른 계산 속도. 기술의 발전으로 현재는 초당 수십억 번의 단방향 해시 계산이 가능합니다.

위의 두 가지 특징을 종합하여 다수의 인간이 사용하는 비밀번호를 자주 집합으로 생각하면, 공격자는 모든 암호 자주 묻는 세트에 대해 단방향 해시를 곱해서 다이제스트 세트 얻기 수 있습니다. 그 데이터베이스에서의 다이제스트와 비교하여 해당 암호를 얻을 수 있습니다. 이 다이제스트 세트를`rainbow table`이라고합니다.

따라서 단방향 암호화를 마친 후 저장된 데이터는 일반 텍스트로 저장되는 것과별로 다르지 않습니다. 그래서 일단 웹 사이트의 데이터베이스를 누설하면 모든 사용자의 암호 자신이 백일하에 노출됩니다.
## 더 나은 방법
위에서는 해커가`rainbow table`를 사용하여 해시 된 암호를 크랙 할 수 있다고 소개했습니다. 대부분의 경우 암호화시 사용 된 해시 알고리즘이 공개 된 것이다 것이 원인입니다. 만약 해커가 암호화 해시 알고리즘이 뭔가를 알아야 어디서부터 손을해야할지 모르겠습니다.

직접적인 해결 방법 중 하나는 자신 해시 알고리즘을 디자인하는 것입니다. 그러나 우수한 해시 알고리즘은 매우 디자인이 어렵습니다 - - 충돌을 피해야합니다 없으며, 알기 쉬운 규칙도 안됩니다. 이 두 가지를 채우는 것은 상상보다 훨씬 어렵습니다. 따라서 실제 응용 프로그램에서는 기존 해시 알고리즘을 이용하여 여러 번 해시 수 이루어집니다.

그러나 간단한 여러 번 해시는 해커를 막을 수 없습니다. 두번의 MD5 나 세 번 MD5 등 우리라도 떠오르는 방법은 해커도 당연히 착상 있습니다. 특히 일부 오픈 소스에 대해이 같은 해시는 직접 알고리즘을 해커에게 말하고있는 것과 같은 것입니다.

깨지지 않는 방패는 없습니다. 그러나 부러지지 억도 또한 없습니다. 현재 보안이 상대적으로 우수한 웹 사이트는 모두 "소금"이라고 불리는 방법으로 암호를 저장합니다. 사람들이 말하는 "salt"입니다. 그들의 일반적인 방법은 우선 사용자가 입력 한 암호에 대한 MD5 (또는 다른 해시 알고리즘) 한 번 암호화합니다. 얻어진 MD5 값의 전후에 관리자 자신 만이 알고있는 임의의 문자열을 추가하여 다시 MD5로 암호화합니다. 이 임의의 문자열에는 어떤 일정한 문자열이 포함되어 있어도 괜찮습니다. 사용자 이름이 포함되어 있어도 괜찮습니다. (각 사용자의 암호화에 사용 된 비밀 키가 일치하지 않음을 보장하기 위해 사용합니다).

// import "crypto / md5"
// 사용자 이름을 abc 암호를 123456합니다
h : = md5.New ()
io.WriteString (h "암호화가 필요한 암호")

// pwmd5는 e10adc3949ba59abbe56e057f20f883e입니다.
pwmd5 : = fmt.Sprintf ( "% x", h.Sum (nil))

// salt를 2 개 지정합니다 : salt1 = @ # $ % salt2 = ^ & * ()
salt1 : = "@ # $ %"
salt2 : = "^ & * ()"

// salt1 + 아이디 + salt2 + MD5를 연결합니다.
io.WriteString (h, salt1)
io.WriteString (h "abc")
io.WriteString (h, salt2)
io.WriteString (h, pwmd5)

last : = fmt.Sprintf ( "% x", h.Sum (nil))

두 salt가 누설되지 않으면 해커는 만약 마지막이 암호화 된 문자열을 손에 넣어도 원래의 암호가 무엇이었을 까 추측하는 것은 거의 불가능합니다.

## 전문적인 방법
위의 "더 나은 방법"몇 년 전에 충분히 안전한 방법 이었을지도 모릅니다. 공격자는 너무 많은`rainbow table`을 만들 충분한 자원이 없었기 때문입니다. 그러나 오늘날에 이르러서는 병렬 컴퓨팅 기능이 향상되면서 이러한 공격은 이미 완전히 가지고 있습니다.

어떻게이 문제를 해결하는 것입니까? 시간과 자원이 허락하면 균열 수없는 암호는 없습니다. 그래서 방법 : 고의로 암호 계산에 필요한 자원과 시간을 증가시킴으로써 아무도`rainbow table`을 만드는 데 필요한 자원을주지 않도록하는 것입니다.

이 방법은 하나의 특징이 있습니다. 알고리즘은 아무도 인자가 있습니다. 암호 다이제스트를 계산하는 데 필요한 자원과 시간을 설명하는 데 사용되는 계산 강도도 있습니다. 계산 강도가 클수록 공격자가`rainbow table`를 작성하는 것이 곤란하게되고 마침내는 계속할 수 없습니다.

여기에서는`scrypt` 방법을 추천합시다. scrypt 유명한 Fr​​eeBSD 해커 인 Colin Percival가 그의 예비의 서비스로 Tarsnap에서 개발했습니다.

현재 Go 언어에서 지원되는 라이브러리 http://code.google.com/p/go/source/browse?repo=crypto#hg%2Fscrypt

dk : = scrypt.Key ([] byte ( "some password") [] byte (salt) 16384, 8, 1, 32)

위의 방법으로 독특한 대응하는 암호 값을 얻을 수 있습니다. 이것은 현재까지 가장 크랙이 어렵습니다.

## 정리
지금까지 당신에 위기감이 싹튼 것이라고하면 행동해야합니다 :

- 1) 만약 일반 사용자라면 LastPass에서 암호를 저장 / 생성하는 것을 추천합니다. 다른 사이트에서 다른 암호를 사용합니다.
- 2) 만약 개발자라면 전문적인 방법으로 암호를 저장하도록 적극 권장합니다.
