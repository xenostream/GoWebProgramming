# CSRF Attacks

## CSRF이란 무엇인가
CSRF (Cross-site request forgery) 우리의 언어는 : "걸터 站请 요구 伪造 (사이트 간 요청 위조)"라고합니다. 또한 one click attack / session riding이라고도 단축하고 : CSRF / XSRF입니다.

CSRF는 무엇을 할 수 있을까요? 이렇게 쉽게 이해할 수 있습니다 : 공격자는 당신의 로그인 정보를 도용 할 수 귀하의 신분에서 모든 요청을 전송하는 경우가 있습니다. 예를 들어 QQ 등 채팅 소프트웨어를 사용하여 링크 (URL 단축 등으로 위장한 것도있어, 사용자는 판별 할 수 없습니다)를 발신하는 등 약간의 사회 공학의 함정을 거는 것만으로 공격자는 Web 어플리케이션의 사용자에 공격 사용자가 설정 한 작업을 수행 할 수 있습니다. 예를 들어, 사용자가 인터넷 뱅킹에 로그인하여 계정 잔액을 확인할 경우 로그 아웃하지 않은 사이에 QQ의 친구로부터 발신 된 링크를 클릭합니다. 그러면이 사용자의 은행 계정의 자금은 공격자가 지정한 계좌에 입금되어 버릴 가능성이 있습니다.

따라서 CSRF 공격을 받았을 때 최종 사용자의 데이터 조작 명령은 심각한 보안 문제입니다. 공격을받은 최종 사용자가 관리자 계정을 가지고 있다면, CSRF 공격은 Web 응용 프로그램의 전체 위기입니다.

## CSRF의 원리
아래의 그림에서 쉽게 CSRF 공격의 사상을 설명합니다

![](9.1.csrf.png)   
그림 9.1 CSRF 공격 과정

위의 그림에서 CSRF 공격을 한 번 성공하려면 피해자가 두 단계를 거쳐야한다 것을 알 수 있습니다 :

- 1. 로그인 페이지 A에서 신임을 받고 로컬에서 Cookie를 생성한다.
- 2.A를 로그 아웃하지 않은 상태에서 위험한 B 페이지에 액세스한다.

지금까지 독자는 다음과 같이 생각 될지도 모릅니다 : "만약 위의 두 가지 조건 중 어느 하나를 만족해야, CSRF 공격을받지 아니한다." 그렇습니다. 확실히 그대로, 그러나 다음과 같은 상황이 발생하지 않는다는 것을 보장 할 수 없습니다 :

- 한 페이지에 로그인 한 뒤, 또 tab 화면을 열고 다른 페이지로 이동하지 않는다고 보장 할 수 없습니다. 특히 최근의 브라우저는 아무도 tab을 지원하고 있습니다.
- 브라우저를 닫은 후 로컬 Cookie가 곧 만료를 맞이하지는 않습니다. 이전 세션이 벌써 종료하고있는 것을 보증 할 수 없습니다.
- 위의 그림에서 보여준 공격 페이지는 다른 보안 취약점을 안고있는 신뢰할 수있는 자주 액세스되는 페이지 일 수 있습니다.

그러므로 사용자에게있는 페이지에 로그인 한 후 어떤 링크를 클릭하여 다른 작업을 피하는 것이 매우 어렵습니다. 그래서 언제든지 CSRF의 피해자가 될 수 있습니다.

CSRF 공격의 주요 원인은 Web 숨겨진 신분 확인 메커니즘에 있습니다. Web 신분 확인 메커니즘의 요청이있는 사용자의 브라우저에서 온 것임을 보장 할 수 있지만,이 요청이 사용자의 승인에 의해 전송 된 것임을 보장 할 수 없습니다.

## 어떻게하고 CSRF를 예방하거나
위의 소개에서 독자는이 같은 공격이 아주 무서운 생각 된 것이 아닐까요. 두려움을 의식하는 것은 좋은 일입니다. 어떻게하고 유사한 보안 구멍의 출현을 방지 / 개선 이후의 내용을 계속 읽어 나갈 것을 촉구줍니다.

CSRF 방어는 서버와 클라이언트 모두에서 착수 할 수 있습니다. 방어는 서버부터 시작하는 것이 효과적입니다. 현재 일반적인 CSRF 방어는 모두 서버에서 이루어집니다.

서버에서 CSRF 공격을 예방하는 방법에는 여러 가지가 있지만 사상에 아무도 다르지 않습니다. 주로 다음의 두 가지 방면에서 이루어집니다 :

- 1 GET, POST와 Cookie를 제대로 사용하려면
- 2, GET이 아닌 요청에 의사 난수를 추가

앞 장에서 REST 메소드의 Web 어플리케이션을 소개했습니다. 일반적으로 보통의 Web 애플리케이션은 아무도 GET, POST가 메인에서 다른 종류의 요청 Cookie 방식입니다. 우리는 일반적으로 다음과 같은 방법으로 응용 프로그램을 설계합니다 :

1, GET 열람 열거 표시 등 자원을 변경할 필요가없는 경우에 한합니다

2 POST는 주문을하고, 자원을 변경하는 등의 상황에 한합니다

에서는 Go 언어를 사용하여 예를 설명합니다. 어떻게 리소스의 액세스 방법을 제한하는 것입니까 :

mux.Get ( "/ user / : uid"getuser)
mux.Post ( "/ user / : uid"modifyuser)

이렇게 처리하면 수정은 POST로 제한하고 있기 때문에 GET 메서드 요청했을 때 응답을 거절합니다. 따라서 위 그림에 표시된 GET 방식의 CSRF 공격은 방지됩니다. 그러나 이것으로 모든 문제가 해결 된 것일까 요? 당연히 그렇지 않습니다. POST도 같기 때문입니다.

따라서 두 번째 단계를 수행해야합니다. GET이 아닌 메소드 요청에서 임의의 숫자를 추가합니다. 이것은 대체로 세 가지 방법으로 실행됩니다 :

- 각 사용자에게 고유 cookie token을 하나 생성합니다. 모든 양식은 같은 의사 난수를 포함합니다. 이 방법은 가장 간단합니다. 왜냐하면 공격자는 타사 Cookie를 (이론적으로) 얻을 수 없으며, 따라서 양식 데이터를 구성 할 수 없습니다. 그러나 사용자의 Cookie는 페이지의 XSS 보안 취약점에 의해 쉽게 도난 버립니다. 따라서이 방법은 반드시 XSS이없는 상황에서 안전하다고 할 수 있습니다.
- 각 요청에 CAPTCHA를 사용합니다. 이 방법은 완벽합니다. 여러 번 CAPTCHA를 입력해야하므로 유용성이 매우 나빠 실제 운영에는 적합하지 않습니다.
- 다른 폼에 각각 다른 의사 난수를 포함합니다. 4.4 절에서 소개 한 "어떻게 양식의 여러 전송을 방지하거나"에서이 방법을 소개했습니다. 관련 코드를 재게합니다 :

임의의 token을 생성합니다

h : = md5.New ()
io.WriteString (h, strconv.FormatInt (crutime 10))
io.WriteString (h "ganraomaxxxxxxxxx")
token : = fmt.Sprintf ( "% x", h.Sum (nil))

t _ : = template.ParseFiles ( "login.gtpl")
t.Execute (w, token)

token을 출력

<input type = "hidden"name = "token"value = "{{}}">

token을 검증

r.ParseForm ()
token : = r.Form.Get ( "token")
if token! = ""{
// token의 적법성을 검증
} else {
// token이 존재하지 않는 경우 오류를 발생
}

이렇게 기본적으로 안전한 POST를 실현했습니다. 그러나 만약 token 알고리즘이 폭로되어 버리면라고 생각 될지도 모릅니다. 그러나 이론적으로 깨진 것은 기본적으로 불가능합니다. 사람이 계산했는데,이 문자열을 무리하게 휴식은 대체로 2 11 승의 시간이 필요합니다.

## 정리
사이트 간 요청 위조, 즉 CSRF는 매우 위험한 Web 보안 문제입니다. Web 보안 근처에서는 "잠자는 거인"라고되어 있습니다. 위험 수준이 "직위"를 보면 아실 겁니다. 이 절에서는 사이트 간 요청 위조의 소개에 그치지 않고 이러한 보안 홀을 만들어내는 원인의 소재에 대해서도 자세히 설명했다. 이제 가지고 공격에 대한 방어를 촉구 독자들에게 안전한 Web 어플리케이션을 써 주시길 기대합니다.

