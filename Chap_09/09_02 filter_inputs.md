# Filter Inputs

사용자의 데이터를 필터링하는 것은 Web 어플리케이션 보안의 기초입니다. 이것은 데이터의 적법성을 검증하는 과정입니다. 모든 입력 데이터에 대해 필터링을 실시하는 것으로, 악의적 인 데이터가 프로그램 중에 실수로 신용되고 사용되는 것을 방지 할 수 있습니다. 대부분의 Web 응용 프로그램의 보안 취약점은 모두 사용자가 입력 한 데이터에 대해 적절한 필터를하지 않은 데 따른 것입니다.

우리가 소개하는 데이터의 필터링은 3 단계로 나누어 져 있습니다 :

- 1 데이터를 식별하고 필터링 할 데이터가 어디에서 왔는지 확실히하기
- 2 데이터를 필터링하여 어떤 데이터가 필요한지 공개
- 3 필터링 된 오염 된 데이터를 구분하고 만약 공격 데이터가 존재하는 경우 필터링 된 우리가 더 안전한 데이터를 사용하도록 보장

## 데이터의 식별
"데이터의 식별"의 첫 걸음은 "데이터가 무엇인지, 어디서 왔는지"를 모른다는 전제가 있기 때문에이를 정확하게 필터링 할 수 없습니다. 여기서 말하는 데이터와 코드의 내부 이외에서 제공되는 모든 데이터를 의미합니다. 예 : 모든 클라이언트에서 데이터 그러나 클라이언트 만이 유일한 외부 데이터 소스라는 것은 없습니다. 데이터베이스와 제 3자가 제공하는 인터페이스 데이터 등도 외부 데이터 원본이 될 수 있습니다.

사용자가 입력 한 데이터는 Go를 사용하여 매우 쉽게 식별 할 수 있습니다. Go는`rParseForm`를 사용하여 사용자의 POST와 GET 데이터를 모두`r.Form`에 저장합니다. 다른 입력은 확인하기가 매우 어렵습니다. 예를 들어`r.Header` 중 많은 요소는 클라이언트가 작업하고 있습니다. 이 중 어떤 요소가 입력되어 있는지 확인하는 것이 어렵고, 따라서 가장 좋은 방법은 안의 모든 데이터를 사용자의 입력으로 간주해 버리는 것입니다. (예를 들어`r.Header.Get ( "Accept-Charset")`같은 것도 대다수는 브라우저가 작동하고 있지만 사용자의 입력으로 간주합니다.)

## 데이터 필터링
데이터의 출처를 알고 있으면 필터링을 할 수 있습니다. 필터링하는 것은 조금 공식적인 용어로 평소 사용하는 말이 많은 동의어가 존재합니다. 예를 들어 확인, 청소, 청소 등입니다. 이러한 용어는 표면적 인 의미는 다르지만 모두 같은 처리를 가리키고 있습니다. 바람직하지 않은 데이터가 귀하의 응용 프로그램에 들어오는 것을 방지합니다.

데이터 필터링에는 여러 가지가 있습니다. 그 중 일부는 안전에 부족하고, 가장 좋은 방법은 필터를 검사 프로세스와 간주해 버리는 것입니다. 당신이 데이터를 사용하기 전에 합법적 인 데이터에 부합 한 요청인지 검사하고 상당히 불법적 인 데이터를 규탄하려고는하지 않고 사용자에 규정 된 규칙에 데이터를 입력하는 것입니다 . 불법적 인 데이터를 규탄하는 것은 종종 보안 문제를 일으킬 것을 역사가 증명하고 있습니다. 예를 들어 보자 : "최근 은행 시스템의 업그레이드가 있은 후 만약 암호 뒤에 두 자리가 0이면 이전 네 자리를 입력하면 시스템에 로그인 할 수 있습니다." 이것은 매우 심각한 보안 홀입니다.

데이터 필터링은 주로 다음과 같은 라이브러리를 사용하여 조작 할 수 있습니다 :

- strconv 패키지의 문자열 변환 관련 함수. Request 중`r.Form`이 반환 문자열이고 때때로 이것을 정수 또는 부동 소수점 숫자로 변환 할 필요가 있기 때문에,`Atoi``ParseBool``ParseFloat``ParseInt` 등 함수를 사용할 수 있습니다.
- string 패키지의 일부 필터링 함수`Trim``ToLower``ToTitle` 같은 함수. 우리가 지정하는 형식에 따라 데이터를 검색 할 수 있습니다.
- regexp 패키지를 사용하여 복잡한 요청을 처리합니다. 예를 들어 입력 Email 여부와 생일 여부를 판단합니다.

데이터 필터링은 검사 및 검증을 제외하고 특별한 경우 화이트리스트를 채용 할 수 있습니다. 즉 예를 들어 당신이 지금 검사하고 데이터가 합법적 인 것을 입증되지 않는 한, 모두 불법이었다고합니다. 이 방법은 만약 오류가 발생하면 합법적 인 데이터를 불법이라고 할지도 모르지만, 그 반대는 없습니다. 어떤 오류도 범하지 생각도 이렇게하는 것은 불법적 인 데이터를 합법적으로 버리는 것보다 훨씬 안전합니다.

## 데이터 필터링의 구별
만약 위의 2 단계가 완료되면 데이터 필터링 작업은 기본적으로 완료되었습니다. 그러나 Web 응용 프로그램을 쓸 때 우리는 이미 필터링하고 오염 된 데이터를 구별해야합니다. 왜냐하면 이렇게하여 데이터 필터링의 무결성을 보장하고, 입력 한 데이터에 영향을주지 않도록 할 수 있기 때문입니다. 우리는 모든 필터링 된 데이터를 글로벌 Map 변수 (CleanMap)에 저장합니다. 이때 두 가지 중요한 단계에서 오염 된 데이터가 주입되는 것을 방지해야합니다 :
- 각 요청은 CleamMap을 하늘의 Map으로 초기화해야합니다.
- 검사를 추가하여 외부 데이터 소스의 변수가 CleanMap되는 것을 방지한다.

계속해서, 예를 하나 들어이 개념을 공고히하자. 아래의 양식을 참조하십시오

<form action = "/ whoami"method = "POST">
당신은 누구입니까 :
<select name = "name">
<option value = "astaxie"> astaxie </ option>
<option value = "herry"> herry </ option>
<option value = "marry"> marry </ option>
</ select>
<input type = "submit"/>
</ form>

이 양식의 프로그램 로직을 처리하고있을 때에, 아주 쉽게 범 버리는 실수는 세 가지 선택 사항 중 하나 만 전송된다고 믿어 버리는 것입니다. 공격자는 POST 작업을 놀 수 있기 때문에,`name = attack` 같은 데이터를 전송할 수 있습니다. 따라서 이때 화이트리스트와 비슷한 작업을 수행해야합니다.

r.ParseForm ()
name : = r.Form.Get ( "name")
CleanMap : = make (map [string] interface {} 0)
if name == "astaxie"|| name == "herry"|| name == "marry"{
CleanMap [ "name"] = name
}

위의 코드에서는 CleamMap라는 변수를 하나 초기화하고 있습니다. 취득 name가`astaxie``herry`, marry` 세 우리 하나라고 판단 한 후 데이터를 CleanMap에 저장합니다. 이렇게 CleanMap [ "name"] 안의 데이터가 합법적임을 보장 할 수 있습니다. 따라서 코드의 다른 부분에도 이것을 사용합니다. 당연히 else 부분에 불법적 인 데이터 처리를 추가해도 괜찮습니다. 다시 폼을 표시 오류를 표시하는 것도 있습니다. 그러나 친절에 오염 된 데이터를 출력하지 마세요.

위의 방법은 이미 알고있는 합법적 인 값 데이터를 필터링하는 데 유용하지만 이미 합법적 인 캐릭터 라인으로 구성되어 있다고 알고 데이터를 필터링 할 경우 아무런 도움도되지 않습니다. 예를 들어, 사용자 이름을 알파벳과 숫자로만 구성하고자하는 경우입니다 :

r.ParseForm ()
username : = r.Form.Get ( "username")
CleanMap : = make (map [string] interface {} 0)
if ok _ : = regexp.MatchString ( "^ [a-zA-Z0-9]. $"username); ok {
CleanMap [ "username"] = username
}

## 정리
데이터 필터링 Web 보안에서 기본 작용입니다. 많은 보안 문제는 데이터의 필터링 및 검증을하지 않은 데 따른 것입니다. 예를 들어 이전 단원의 CSRF 공격과 이후에 설명하는 XSS 공격, SQL 인젝션 등은 모두 성실하게 데이터를 필터링하지 않은 것에 기인합니다. 따라서이 부분의 내용은 특히 중시해야합니다.

